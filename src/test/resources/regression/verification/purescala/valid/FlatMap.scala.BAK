import leon.lang._
import leon.collection._

object Lists5 {

  def append[T](l1: List[T], l2: List[T]): List[T] = l1 match {
    case Cons(head, tail) => Cons(head, append(tail, l2))
    case Nil() => l2
  }

  def associative_append_lemma[T](l1: List[T], l2: List[T], l3: List[T]): Boolean = {
    append(append(l1, l2), l3) == append(l1, append(l2, l3))
  }

  def associative_append_lemma_induct[T](l1: List[T], l2: List[T], l3: List[T]): Boolean = {
    l1 match {
      case Nil() => associative_append_lemma(l1, l2, l3)
      case Cons(head, tail) => associative_append_lemma(l1, l2, l3) && associative_append_lemma_induct(tail, l2, l3)
    }
  }.holds

  def flatMap[T,U](list: List[T], f: T => List[U]): List[U] = list match {
    case Cons(head, tail) => append(f(head), flatMap(tail, f))
    case Nil() => Nil()
  }

  def associative_lemma[T,U,V](list: List[T], f: T => List[U], g: U => List[V]): Boolean = {
    flatMap(flatMap(list, f), g) == flatMap(list, (x: T) => flatMap(f(x), g))
  }

  def associative_lemma_helper[T,U,V](fprev: List[U], fcur: List[U], fgprev: List[V], fgcur: List[V], tail: List[T], f: T => List[U], g: U => List[V]): Boolean = {
    val left = fcur match {
      case Cons(fhead, ftail) =>
        flatMap(append(fprev, Cons(fhead, append(ftail, flatMap(tail, f)))), g)
      case Nil() =>
        flatMap(append(fprev, flatMap(tail, f)), g)
    }

    val right = fgcur match {
      case Cons(fghead, fgtail) =>
        append(fgprev, Cons(fghead, append(fgtail, flatMap(tail, (x: T) => flatMap(f(x), g)))))
      case Nil() =>
        append(fgprev, flatMap(tail, (x: T) => flatMap(f(x), g)))
    }
        
    left == right && (fgcur match {
      case Cons(fghead, fgtail) => associative_lemma_helper(fprev, fcur, append(fgprev, Cons(fghead, Nil())), fgtail, tail, f, g)
      case Nil() => fcur match {
        case Cons(fhead, ftail) => associative_lemma_helper(append(fprev, Cons(fhead, Nil())), ftail, fgprev, fgcur, tail, f, g)
        case Nil() => tail match {
          case Nil() => true
          case Cons(head, tail) => f(head) match {
            case fl @ Cons(fh, ft) => associative_lemma_helper(Nil(), fl, Nil(), flatMap(fl, g), tail, f, g)
            case Nil() => associative_lemma_helper(Nil(), Nil(), Nil(), Nil(), tail, f, g)
          }
        }
      }
    })
  }

  def associative_lemma_induct[T,U,V](list: List[T], f: T => List[U], g: U => List[V]): Boolean = {
    list match {
      case Nil() => associative_lemma(list, f, g)
      case Cons(head, tail) =>
        associative_lemma(list, f, g) && associative_lemma_induct(tail, f, g) && associative_lemma_helper(Nil(), Nil(), Nil(), Nil(), list, f, g)
    }
  }.holds

}
