package leon
package invariant.util

import purescala.Common._
import purescala.Definitions._
import purescala.Trees._
import purescala.TreeOps._
import purescala.Extractors._
import purescala.TypeTrees._
import scala.collection.mutable.{ Set => MutableSet }
import scala.collection.immutable.Stack
import java.io._
import scala.collection.mutable.{ Set => MutableSet }
import java.io._
import solvers.z3._
import solvers._
import invariant.engine._
import invariant.factories._
import invariant.structure._
import leon.smtlib._
import _root_.smtlib.sexpr.SExprs._
import _root_.smtlib._
import _root_.smtlib.Commands.{ Command, Assert, NonStandardCommand }
import _root_.smtlib.{ PrettyPrinter => SMTPrinter }

/**
 * Some utils that need not be a part of
 * mainstream utilities
 */
object MiscUtil {

  def toBracelogicSMTLIB(inExpr: Expr,
    filePrefix: String,
    ctx: LeonContext,
    sol: Option[Map[Identifier, Expr]]) = {
    //replace all reals by integers
    val realToInt = new RealToInt()
    val intExpr = realToInt.mapRealToInt(inExpr)
    val intSol = if (sol.isDefined) Some(realToInt.mapModel(sol.get))
    			 else sol

    val converter = new SMTLIBConverter(ctx)
    val (commands, sexpr) = converter.toSExprAndDefinitions(Not(intExpr))
    //collect all non-template variables in intExpr
    val varmap = converter.target.variables
    val freevars = variablesOf(intExpr).collect {
      case vid if !TemplateIdFactory.IsTemplateIdentifier(vid) => 
        SList(varmap.getB(vid).get, converter.target.sorts.getB(vid.getType).get)
    }        

    //universally quantify all the non-template variables
    val quantSExpr = SList(SSymbol("forall"), SList(freevars.toList), sexpr)
    val bodyCommands = (commands :+ Assert(quantSExpr) :+
    						NonStandardCommand(SList(SSymbol("check-sat")))) ++
						      (if (intSol.isDefined)
						        List(NonStandardCommand(SList(SSymbol("get-model"))))
						      else List())    						 

    //TODO: add logic also to the header 
    //SList(List(SSymbol("set-logic"), SSymbol("ALL_SUPPORTED"))),
    val header = List(NonStandardCommand(SComment("Automatically Generated by Leon/Orb (http://lara.epfl.ch/w/rbound)")))
    val solstr = intSol match {
      case None => "Unsat"
      case Some(model) =>
        model.collect {
          case (k, v) if varmap.containsA(k) =>
            varmap.getB(k).get.s + "->" + v.toString
        }.mkString(", ")
    }
    val trailer = List(NonStandardCommand(SComment("Orb solution (can be reals): " + solstr)))
    
    val filename = filePrefix + (if(intSol.isDefined) "-sat" else "-unsat")      
    writeSMTFile(filename, header, bodyCommands, trailer)

    //for cross verification
    //if there exists a solution, dump an smtlib file that asserts the solution 
    //and the unquantified body
    /*if (intSol.isDefined && !intSol.get.values.exists(_.isInstanceOf[RealLiteral])) {      
      val exprWithSolution = And(intExpr, Util.modelToExpr(intSol.get))
      val (commands, sexpr) = (new SMTLIBConverter(ctx)).toSExprAndDefinitions(exprWithSolution)
      val body = commands :+ Assert(sexpr) :+ NonStandardCommand(SList(SSymbol("check-sat")))       
      writeSMTFile(filePrefix+"-verify", header, body, List())
    }*/    
  }

  def writeSMTFile(filename: String, header: List[Command], body: List[Command], trailer: List[Command]) = {
    //dump to an smtlib file
    val writer = new PrintWriter(filename+".smt2")
    def writeCmds(cmds: List[Command]) = cmds.foreach {
      case cmd =>
        SMTPrinter(cmd, writer)
        writer.println()
    }
    writeCmds(header)
    writer.println()
    writeCmds(body)
    writer.println()
    writeCmds(trailer)
    writer.println()
    writer.flush()
    writer.close()
  }

}