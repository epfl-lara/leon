package leon
package horncl

import purescala._
import Common._
import Trees._
import Extractors._
import TreeOps._
import TypeTrees._
import Definitions._
import SExprs._
import invariant.util.ExpressionTransformer
import invariant.util.TVarFactory
import leon.invariant.util.ExpressionTransformer

/** This pretty-printer prints an SMTLIB2 representation of the Purescala program */
class HornClausePrinter(pgm: Program) {

  private var errorConstants: Set[(SSymbol, SExpr)] = Set()
  private var classDecls = Seq[SExpr]()  
  private var funDecls = Seq[SExpr]()
  
  //a mapping from tuple types to ADTs
  private var tts = Map[TupleType, CaseClassDef]()
  //a mapping from functions to relational version of the function
  private var funs = Map[FunDef, FunDef]()
  //new created horn predicates
  var hornRels = Set[FunDef]()
  
  val tru = BooleanLiteral(true)
  val fls = BooleanLiteral(false)

  def toSmtLib: String = {
    errorConstants = Set()

    //get all user defined classes
    val defs: Seq[ClassDef] = pgm.definedClasses
    //println("Classes: "+defs.map(_.id))
    
    //partition them into parent, children
    /*val partition: Seq[(ClassDef, Seq[CaseClassDef])] = {
      val parents: Seq[ClassDef] = defs.filter(!_.hasParent)
      parents.map(p => (p, defs.filter(_.isInstanceOf[CaseClassDef]).filter(c => c.parent match {
        case Some(p2) => p == p2
        case None => p == c //here parent and children are the same class
      }).asInstanceOf[Seq[CaseClassDef]]))
    }*/    
    val partition = defs.collect {
      case root: ClassDef if !root.hasParent => { 
        (root, root.knownChildren.collect{case t: CaseClassDef => t})
      }      
    } 
    //create a smtlib class decl for each parent-children pair
    partition.foreach{ case (parent, children) => classDeclToSmtlibDecl(parent, children)}

    //create new function declarations 
    //More functions may be added while processing functions
    pgm.definedFunctions.foreach((fd) => {
      if (fd.returnType == UnitType)
        throw new IllegalStateException("Return Type of function is unit: " + fd.id)

      val newfd = new FunDef(FreshIdentifier(fd.id.name, true), fd.tparams, BooleanType,
        fd.params :+ ValDef(FreshIdentifier("res", true).setType(fd.returnType), fd.returnType))
      
      hornRels += newfd
      funs += (fd -> newfd)
    })  
        
    //new tuple types could be discovered in the program while processing functions    
    val convertedFunDefs = pgm.definedFunctions.foldLeft(Seq[SExpr]())((acc, fd) => acc ++ fd2sexp(fd))
       
    val sortDecls = classDecls.map((clsdec) => SList(SSymbol("declare-datatypes"), SList(), SList(clsdec)))
    //println(sortDecls)
    val funDecls = funs.values.map(getFunDecl(_))
    
    val sortErrors: List[SExpr] = errorConstants.map(p => SList(SSymbol("declare-const"), p._1, p._2)).toList  

    (      
      SComment("Automatically Generated by Leon (http://lara.epfl.ch/w/leon)") +:      
      SList(List(SSymbol("set-logic"), SSymbol("HORN"))) +:
      ( sortDecls ++
        funDecls ++
        sortErrors ++
        convertedFunDefs         
        //Seq(SList(SSymbol("check-sat")))
        //++ Seq(SList(SSymbol("check-sat-using"), SList(SSymbol("with horn :engine tab"))))
        /*SList(SSymbol("get-model")))*/
      )
    ).map(SExprs.toString(_)).mkString("\n")

  }
  
  def getFunDecl(fd: FunDef) : SExpr ={
    val name = id2sym(fd.id)
    val returnSort = tpe2sort(fd.returnType)
    val varDecls: List[(SSymbol, SExpr)] = fd.params.map(vd => (id2sym(vd.id), tpe2sort(vd.tpe))).toList
    SList(SSymbol("declare-fun"), name, SList(varDecls.map(_._2)), SSymbol("Bool"))
  }

  /**
   * Given the parent classdef (abstractClassDef) and the children classDef (CaseClassDef)
   * adds a smtlib class def to the classDecl  
   */
  private def classDeclToSmtlibDecl(parent: ClassDef, children: Seq[CaseClassDef])  = {
    val name = id2sym(parent.id)
    val constructors: List[SExpr] = children.map(child => {
      val fields: List[SExpr] = child.fields.map { case ValDef(id, tpe) => SList(id2sym(id), tpe2sort(tpe)) }.toList
      if (fields.isEmpty) SList(id2sym(child.id)) else SList(id2sym(child.id) :: fields)
    }).toList

    classDecls :+= SList(name :: constructors)
  }


  private def id2sym(id: Identifier) = SSymbol(id.uniqueName)

  /**
   * Create a new smtlib datatype for the input tuple.
   * This will add the newly created type to classDecls
   */  
  private def tupleTypeToCaseClassDef(tt: TupleType) : CaseClassDef = {
    if(tts.contains(tt)) tts(tt)
    else {
      //create a tuple field name for each field      
      val tupleFields = tt.bases.map((tpe: TypeTree) => ValDef(FreshIdentifier("tuple-field", true).setType(tpe), tpe))                
      val ccd = new CaseClassDef(FreshIdentifier("Tuple", true), Seq(), None, false)
      ccd.setFields(tupleFields)
      
      //add ccd to smtlib decls
      classDeclToSmtlibDecl(ccd, Seq(ccd))
      
      //add ccd to tts
      tts += (tt -> ccd)
      ccd
    }
  }

  def tpe2sort(tpe: TypeTree): SExpr = tpe match {
    case Int32Type => SSymbol("Int")
    case BooleanType => SSymbol("Bool")
    case ArrayType(baseTpe) => SList(SSymbol("Array"), SSymbol("Int"), tpe2sort(baseTpe))
    case AbstractClassType(abs, tps) => id2sym(abs.id)
    case CaseClassType(cc, tps) => {
      if(cc.parent.isDefined){
        //use the parent        
        id2sym(cc.parent.get.id)
      } else
        id2sym(cc.id)
    }
    case tt@TupleType(_) => {
      val cc = tupleTypeToCaseClassDef(tt)
      id2sym(cc.id)
    }
    case _ => sys.error("TODO tpe2sort: " + tpe)
  }

  //return a series of declarations, an expression that defines the function, 
  //and the seq of asserts for pre/post-conditions
  private def fd2sexp(fd: FunDef): Seq[SExpr] = {
    val resid = FreshIdentifier("res",true).setType(fd.returnType)
    val resvar = resid.toVariable
    var implications = Seq[Expr]()
    //flattenBody         
    if (fd.hasBody) {
      //convert the body to a horn expression with an auxiliary set of implications
      val params = fd.params.map(_.id)
      val paramsRes = params :+ resid      
      val (hornBody, imps) = leonToHorn(Equals(resvar, fd.body.get))
      implications ++= imps      
      //create an implication that (hornBody => fdRel)
      
      val bodyRel = FunctionInvocation(TypedFunDef(funs(fd), Seq()), paramsRes.map(_.toVariable))      
      implications :+= Implies(hornBody, bodyRel)
      
      if(fd.hasPostcondition && fd.postcondition.get._2 != BooleanLiteral(true)) {
        val (r,pexpr) = fd.postcondition.get
        val postExpr = replace(Map(r.toVariable -> resvar), pexpr)
        
        //create relations for post-condition as in the case of body  (but use negation of post-condition)     
        val (hornPost, imps) = leonToHorn(Not(postExpr))
        implications ++= imps      
        
        //create an implication that (postRel ^ HornPost => false)
        val postArgs = variablesOf(postExpr).toSeq.map(_.toVariable)
        val postFd = createNewRelation(postArgs.map(_.getType))
        val postRel = FunctionInvocation(TypedFunDef(postFd,Seq()), postArgs)
        implications :+= Implies(And(postRel, hornPost), BooleanLiteral(false))
        
        if(fd.hasPrecondition) {
          //do the same as body and post       
          val preExpr = fd.precondition.get
          val preArgs = variablesOf(preExpr).toSeq.map(_.toVariable)
          val (hornPre, imps) = leonToHorn(preExpr)
          implications ++= imps      
          //create an implication that (hornPost => postRel)
          val preFd = createNewRelation(preArgs.map(_.getType))
          val preRel = FunctionInvocation(TypedFunDef(preFd,Seq()), preArgs)
          implications :+= Implies(hornPre, preRel)
          
          //add pre ^ body => post
          implications :+= Implies(And(preRel, bodyRel), postRel)
        } else {
          //add body => post
          implications :+= Implies(bodyRel, postRel)
        }        
      }
      //add determinism constraints
      //create a new relation for body
      val resvar2 = FreshIdentifier("res", true).setType(fd.returnType).toVariable
      val bodyRel2 = replace(Map(resvar -> resvar2), bodyRel)
      implications :+= Implies(And(bodyRel, bodyRel2), Equals(resvar, resvar2))

       //convert leon implications to SExprs
      implications.map((imp) => {
        //convert implication to sexpr
        val impbody = exp2sexp(imp)
        //quantify over all free variables in 'imp'
        val freesyms = variablesOf(imp).map((id) => SList(List(id2sym(id), tpe2sort(id.getType)))).toList        
        val quantFormula = SList(SSymbol("forall"), SList(freesyms), impbody)
        
        //assert the formula
        SList(SSymbol("assert"), quantFormula)
      })                 
    } else {
      //no body
      throw new IllegalArgumentException("Warning no body found for : "+fd.id)
    }    
  }

  
  private def createNewRelation(types : Seq[TypeTree]) : FunDef = {
    val newRel = new FunDef(FreshIdentifier("P",true), Seq(), BooleanType, 
        types.map((tpe) => ValDef(FreshIdentifier("arg",true).setType(tpe),tpe)))
    
    hornRels += newRel
    funs += (newRel -> newRel)
    newRel
  }

  //converts an arbitrary leon expression to a horn clause
  private def leonToHorn(expr: Expr) : (Expr, Seq[Expr]) = {
    val simpExpr = matchToIfThenElse(expr)       
    //Do not flatten functions here. Flatten them while creating clauses
    val nnfExpr = {
      ExpressionTransformer.pullAndOrs(
    	ExpressionTransformer.TransformNot(
          ExpressionTransformer.reduceLangBlocks(simpExpr,Times), retainNEQ = true 
          )
       )
    }
    //replace all the function calls by predicates given by 'funs'
    val (resExpr, imps) = formulaToHorn(nnfExpr)
    (toHorn(resExpr), imps)
  }
  
  private def toHorn(body: Expr) : Expr = {
    //This is an optimization: separate predicates in the body that are not nested from the rest.
    //Such predicates need not be flattened    
    var preds = Seq[Expr]()
    var constraints = Seq[Expr]()
    
    def isHornPred(p : Expr) : Boolean = {
      p match {
        case FunctionInvocation(tfd, _) => hornRels.contains(tfd.fd)
        case _ => false
      }      
    }
    
    body match {
      case And(args) => {
        args.foreach(arg => {
          if(isHornPred(arg)) preds :+= arg
          else constraints :+= arg
        })
      }
      case _ => {
        if(isHornPred(body)) preds :+= body
        else constraints :+= body    
      }      
    }
       
    //flatten constraints (note this may introduce iff operation which are handled specially)
    val flatCtr = ExpressionTransformer.FlattenFunction(And(constraints))
    
    //Create a mapping for each boolean valued function/instance-of check, from the return value to the call
    var boolResMap = Map[Variable,Expr]()
    simplePostTransform((e: Expr) => e match {
      case Iff(r @ Variable(_), fi @ FunctionInvocation(tfd, _)) => {
        if(!hornRels.contains(tfd.fd)) 
          boolResMap += (r -> fi)
        e
      }          
      case Iff(r@Variable(_), ins@CaseClassInstanceOf(_, _)) => {
    	 boolResMap += (r -> ins)
    	 e
      }
      case _ => e
    })(flatCtr)       
    
    //reduce terms in expressions
    val redctr = simplePostTransform((e) => e match {
      //convert case-class-selectors and tuple-selectors to constructors
      case Equals(Variable(_), CaseClassSelector(_, _, _)) | Iff(Variable(_), CaseClassSelector(_, _, _)) => {
        ExpressionTransformer.classSelToCons(e)
      }
      case Equals(Variable(_), TupleSelect(_, _)) | Iff(Variable(_), TupleSelect(_, _)) => {
        ExpressionTransformer.tupleSelToCons(e)
      }
      //retain Iff only if fd is a horn relations
      case Iff(Variable(_), FunctionInvocation(tfd, _)) => {        
        if(hornRels.contains(tfd.fd)) e
        else tru
      }
      //remove all case-class-instance-of
      case Iff(Variable(_), CaseClassInstanceOf(_, _)) => tru
      case _ => e
    })(flatCtr)    
       
    val hornctr = simplePreTransform((e: Expr) => e match {
      //replace functions calls by predicates 
      case Equals(r @ Variable(_), fi @ FunctionInvocation(TypedFunDef(fd,tps), args)) => FunctionInvocation(TypedFunDef(funs(fd),tps), args :+ r)    
      //if 'r' is a return value of a boolean function then replace 'r' by a predicate
      case Not(r @ Variable(_)) => {        
        if (boolResMap.contains(r)) {
          val boolExpr = boolResMap(r)
          boolExpr match {
            case FunctionInvocation(TypedFunDef(fd,tps), args) => FunctionInvocation(TypedFunDef(funs(fd),tps), args :+ fls)
            case CaseClassInstanceOf(cd, arg) => {
              //make ~(args = ccd(dummy*))
              val ccArgs = cd.fields.map((fld) => TVarFactory.createDummy.setType(fld.getType).toVariable)
              Not(Equals(arg, CaseClass(cd, ccArgs)))
            }
            case _ => throw IllegalStateException("boolExpr mismatch: "+boolExpr)
          }
        } else e
      }
      case r@Variable(_) => {        
        if (boolResMap.contains(r)) {
          val boolExpr = boolResMap(r)
          boolExpr match {
            case FunctionInvocation(TypedFunDef(fd,tps), args) => FunctionInvocation(TypedFunDef(funs(fd),tps), args :+ tru)
            case CaseClassInstanceOf(cd, arg) => {
              //make args = ccd(dummy*)
              val ccArgs = cd.fields.map((fld) => TVarFactory.createDummy.setType(fld.getType).toVariable)
              Equals(arg, CaseClass(cd, ccArgs))
            }
            case _ => throw IllegalStateException("boolExpr mismatch: "+boolExpr)
          }
        } else e
      }
      case _ => e
    })(redctr)    
    
    //println("hornctr: "+hornctr)
    ExpressionTransformer.pullAndOrs(And(preds :+ hornctr))
  }
  
  /**
   * converts a nnf formula to Horn clauses by creating new relations for disjunctions
   */
  private def formulaToHorn(expr: Expr) : (Expr, Seq[Expr]) ={
    
    var implications = Seq[Expr]() 
    val hornBody = simplePostTransform((e: Expr) => e match {     
      case Or(args) => {
        //println("subexp: "+ScalaPrinter(e))
        //get variables common to all args
        val freeVars = args.foldLeft(Set[Identifier]())((acc,arg) => {
          acc ++ variablesOf(arg)
        }).toSeq
        //create new Relation
        val newRel = createNewRelation(freeVars.map(_.getType))        
        val relApp = FunctionInvocation(TypedFunDef(newRel,Seq()), freeVars.map(_.toVariable))
        
        //here, create a bunch of implications
        implications ++= args.map((arg) => Implies(toHorn(arg),relApp))                
        relApp
      }
      case Implies(_,_) => throw new IllegalStateException("Implies encountered in the formula: "+e)      
      case _ => e
    })(expr)
    (hornBody, implications)
  }
  
  def exp2sexp(tree: Expr): SExpr = tree match {    
         
    case Variable(id) => id2sym(id)
    case LetTuple(ids,d,e) => {
      //convert LetTuple to Lets
      val rootid = FreshIdentifier("lt",true).setType(d.getType)
      val rootvar = rootid.toVariable
      val ts = ids.size
      val subexpr = ids.foldRight(e)((id, acc) => {
        Let(id, TupleSelect(rootvar, ts), acc)
      })      
      exp2sexp(Let(rootid, d, subexpr))
    }
    case Let(b,d,e) => SList(
      SSymbol("let"),
      SList(
        SList(id2sym(b), exp2sexp(d))
      ),
      exp2sexp(e)
    )
    case And(exprs) => SList(SSymbol("and") :: exprs.map(exp2sexp).toList)
    case Or(exprs) => SList(SSymbol("or") :: exprs.map(exp2sexp).toList)
    case Not(expr) => SList(SSymbol("not"), exp2sexp(expr))
    case Equals(l,r) => SList(SSymbol("="), exp2sexp(l), exp2sexp(r))
    case IntLiteral(v) => SInt(v)
    case BooleanLiteral(v) => SSymbol(v.toString) //TODO: maybe need some builtin type here
    case StringLiteral(s) => SString(s)

    case Implies(l,r) => SList(SSymbol("=>"), exp2sexp(l), exp2sexp(r))
    case Iff(l,r) => SList(SSymbol("="), exp2sexp(l), exp2sexp(r))

    case Plus(l,r) => SList(SSymbol("+"), exp2sexp(l), exp2sexp(r))
    case UMinus(expr) => SList(SSymbol("-"), exp2sexp(expr))
    case Minus(l,r) => SList(SSymbol("-"), exp2sexp(l), exp2sexp(r))
    case Times(l,r) => SList(SSymbol("*"), exp2sexp(l), exp2sexp(r))
    case Division(l,r) => SList(SSymbol("div"), exp2sexp(l), exp2sexp(r))
    case Modulo(l,r) => SList(SSymbol("mod"), exp2sexp(l), exp2sexp(r))
    case LessThan(l,r) => SList(SSymbol("<"), exp2sexp(l), exp2sexp(r))
    case LessEquals(l,r) => SList(SSymbol("<="), exp2sexp(l), exp2sexp(r))
    case GreaterThan(l,r) => SList(SSymbol(">"), exp2sexp(l), exp2sexp(r))
    case GreaterEquals(l,r) => SList(SSymbol(">="), exp2sexp(l), exp2sexp(r))

    case IfExpr(c, t, e) => SList(SSymbol("ite"), exp2sexp(c), exp2sexp(t), exp2sexp(e))

    case FunctionInvocation(fd, args) => SList(id2sym(fd.id) :: args.map(exp2sexp).toList)

    case ArrayFill(length, defaultValue) => SList(
      SList(SSymbol("as"), SSymbol("const"), tpe2sort(tree.getType)),
      exp2sexp(defaultValue)
    )
    case ArrayMake(defaultValue) => SList(
      SList(SSymbol("as"), SSymbol("const"), tpe2sort(tree.getType)),
      exp2sexp(defaultValue)
    )
    case ArraySelect(array, index) => SList(SSymbol("select"), exp2sexp(array), exp2sexp(index))
    case ArrayUpdated(array, index, newValue) => SList(SSymbol("store"), exp2sexp(array), exp2sexp(index), exp2sexp(newValue))

    case CaseClass(ccd, args) =>{
      if(args.isEmpty) id2sym(ccd.id)
      else {
        //in this case, create a function application
        SList(id2sym(ccd.id) :: args.map(exp2sexp(_)).toList)  
      }      
    } 
    case tp@Tuple(args) => {
      val ccd = tupleTypeToCaseClassDef(tp.getType.asInstanceOf[TupleType])
      SList(id2sym(ccd.id) :: args.map(exp2sexp(_)).toList)
    }       
    
    case CaseClassSelector(_, arg, field) => {
      //SList(id2sym(field), exp2sexp(arg))
      throw IllegalStateException("Encountered CaseClassSelector in exp2sexpr: "+tree)
    }
    case TupleSelect(arg, index) => {
      /*val ccd = tupleTypeToCaseClassDef(arg.getType.asInstanceOf[TupleType])
      //get field at index 'index'
      val field = ccd.fieldsIds(index - 1)
      SList(id2sym(field), exp2sexp(arg))*/      
      throw IllegalStateException("Encountered TupleSelector in exp2sexpr: "+tree)
    }
    case CaseClassInstanceOf(ccd, arg) => {
      /*val name = id2sym(ccd.id)
      val testerName = SSymbol("is-" + name.s)
      SList(testerName, exp2sexp(arg))*/
      throw IllegalStateException("Encountered InstanceOf in exp2sexpr: "+tree)
    }
    case er@Error(_) => {
      val id = id2sym(FreshIdentifier("error_value").setType(er.getType))
      errorConstants += ((id, tpe2sort(er.getType)))
      id
    }

    case o => sys.error("TODO converting to smtlib: " + o)
  }
}
